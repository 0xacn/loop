// Code generated by protoc-gen-go. DO NOT EDIT.
// source: client.proto

package looprpc

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type SwapType int32

const (
	// LOOP_OUT indicates an loop out swap (off-chain to on-chain)
	SwapType_LOOP_OUT SwapType = 0
	// LOOP_IN indicates a loop in swap (on-chain to off-chain)
	SwapType_LOOP_IN SwapType = 1
)

var SwapType_name = map[int32]string{
	0: "LOOP_OUT",
	1: "LOOP_IN",
}

var SwapType_value = map[string]int32{
	"LOOP_OUT": 0,
	"LOOP_IN":  1,
}

func (x SwapType) String() string {
	return proto.EnumName(SwapType_name, int32(x))
}

func (SwapType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{0}
}

type SwapState int32

const (
	//*
	//INITIATED is the initial state of a swap. At that point, the initiation
	//call to the server has been made and the payment process has been started
	//for the swap and prepayment invoices.
	SwapState_INITIATED SwapState = 0
	//*
	//PREIMAGE_REVEALED is reached when the sweep tx publication is first
	//attempted. From that point on, we should consider the preimage to no
	//longer be secret and we need to do all we can to get the sweep confirmed.
	//This state will mostly coalesce with StateHtlcConfirmed, except in the
	//case where we wait for fees to come down before we sweep.
	SwapState_PREIMAGE_REVEALED SwapState = 1
	//*
	//HTLC_PUBLISHED is reached when the htlc tx has been published in a loop in
	//swap.
	SwapState_HTLC_PUBLISHED SwapState = 2
	//*
	//SUCCESS is the final swap state that is reached when the sweep tx has
	//the required confirmation depth.
	SwapState_SUCCESS SwapState = 3
	//*
	//FAILED is the final swap state for a failed swap with or without loss of
	//the swap amount.
	SwapState_FAILED SwapState = 4
	//*
	//INVOICE_SETTLED is reached when the swap invoice in a loop in swap has been
	//paid, but we are still waiting for the htlc spend to confirm.
	SwapState_INVOICE_SETTLED SwapState = 5
)

var SwapState_name = map[int32]string{
	0: "INITIATED",
	1: "PREIMAGE_REVEALED",
	2: "HTLC_PUBLISHED",
	3: "SUCCESS",
	4: "FAILED",
	5: "INVOICE_SETTLED",
}

var SwapState_value = map[string]int32{
	"INITIATED":         0,
	"PREIMAGE_REVEALED": 1,
	"HTLC_PUBLISHED":    2,
	"SUCCESS":           3,
	"FAILED":            4,
	"INVOICE_SETTLED":   5,
}

func (x SwapState) String() string {
	return proto.EnumName(SwapState_name, int32(x))
}

func (SwapState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{1}
}

type LoopOutRequest struct {
	//*
	//Requested swap amount in sat. This does not include the swap and miner fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//*
	//Base58 encoded destination address for the swap.
	Dest string `protobuf:"bytes,2,opt,name=dest,proto3" json:"dest,omitempty"`
	//*
	//Maximum off-chain fee in msat that may be paid for payment to the server.
	//This limit is applied during path finding. Typically this value is taken
	//from the response of the GetQuote call.
	MaxSwapRoutingFee int64 `protobuf:"varint,3,opt,name=max_swap_routing_fee,json=maxSwapRoutingFee,proto3" json:"max_swap_routing_fee,omitempty"`
	//*
	//Maximum off-chain fee in msat that may be paid for payment to the server.
	//This limit is applied during path finding. Typically this value is taken
	//from the response of the GetQuote call.
	MaxPrepayRoutingFee int64 `protobuf:"varint,4,opt,name=max_prepay_routing_fee,json=maxPrepayRoutingFee,proto3" json:"max_prepay_routing_fee,omitempty"`
	//*
	//Maximum we are willing to pay the server for the swap. This value is not
	//disclosed in the swap initiation call, but if the server asks for a
	//higher fee, we abort the swap. Typically this value is taken from the
	//response of the GetQuote call. It includes the prepay amount.
	MaxSwapFee int64 `protobuf:"varint,5,opt,name=max_swap_fee,json=maxSwapFee,proto3" json:"max_swap_fee,omitempty"`
	//*
	//Maximum amount of the swap fee that may be charged as a prepayment.
	MaxPrepayAmt int64 `protobuf:"varint,6,opt,name=max_prepay_amt,json=maxPrepayAmt,proto3" json:"max_prepay_amt,omitempty"`
	//*
	//Maximum in on-chain fees that we are willing to spent. If we want to
	//sweep the on-chain htlc and the fee estimate turns out higher than this
	//value, we cancel the swap. If the fee estimate is lower, we publish the
	//sweep tx.
	//
	//If the sweep tx is not confirmed, we are forced to ratchet up fees until it
	//is swept. Possibly even exceeding max_miner_fee if we get close to the htlc
	//timeout. Because the initial publication revealed the preimage, we have no
	//other choice. The server may already have pulled the off-chain htlc. Only
	//when the fee becomes higher than the swap amount, we can only wait for fees
	//to come down and hope - if we are past the timeout - that the server is not
	//publishing the revocation.
	//
	//max_miner_fee is typically taken from the response of the GetQuote call.
	MaxMinerFee int64 `protobuf:"varint,7,opt,name=max_miner_fee,json=maxMinerFee,proto3" json:"max_miner_fee,omitempty"`
	//*
	//The channel to loop out, the channel to loop out is selected based on the
	//lowest routing fee for the swap payment to the server.
	LoopOutChannel uint64 `protobuf:"varint,8,opt,name=loop_out_channel,json=loopOutChannel,proto3" json:"loop_out_channel,omitempty"`
	//*
	//The number of blocks from the on-chain HTLC's confirmation height that it
	//should be swept within.
	SweepConfTarget      int32    `protobuf:"varint,9,opt,name=sweep_conf_target,json=sweepConfTarget,proto3" json:"sweep_conf_target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoopOutRequest) Reset()         { *m = LoopOutRequest{} }
func (m *LoopOutRequest) String() string { return proto.CompactTextString(m) }
func (*LoopOutRequest) ProtoMessage()    {}
func (*LoopOutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{0}
}

func (m *LoopOutRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoopOutRequest.Unmarshal(m, b)
}
func (m *LoopOutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoopOutRequest.Marshal(b, m, deterministic)
}
func (m *LoopOutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopOutRequest.Merge(m, src)
}
func (m *LoopOutRequest) XXX_Size() int {
	return xxx_messageInfo_LoopOutRequest.Size(m)
}
func (m *LoopOutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopOutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoopOutRequest proto.InternalMessageInfo

func (m *LoopOutRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *LoopOutRequest) GetDest() string {
	if m != nil {
		return m.Dest
	}
	return ""
}

func (m *LoopOutRequest) GetMaxSwapRoutingFee() int64 {
	if m != nil {
		return m.MaxSwapRoutingFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxPrepayRoutingFee() int64 {
	if m != nil {
		return m.MaxPrepayRoutingFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxSwapFee() int64 {
	if m != nil {
		return m.MaxSwapFee
	}
	return 0
}

func (m *LoopOutRequest) GetMaxPrepayAmt() int64 {
	if m != nil {
		return m.MaxPrepayAmt
	}
	return 0
}

func (m *LoopOutRequest) GetMaxMinerFee() int64 {
	if m != nil {
		return m.MaxMinerFee
	}
	return 0
}

func (m *LoopOutRequest) GetLoopOutChannel() uint64 {
	if m != nil {
		return m.LoopOutChannel
	}
	return 0
}

func (m *LoopOutRequest) GetSweepConfTarget() int32 {
	if m != nil {
		return m.SweepConfTarget
	}
	return 0
}

type LoopInRequest struct {
	//*
	//Requested swap amount in sat. This does not include the swap and miner
	//fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//*
	//Maximum we are willing to pay the server for the swap. This value is not
	//disclosed in the swap initiation call, but if the server asks for a
	//higher fee, we abort the swap. Typically this value is taken from the
	//response of the GetQuote call.
	MaxSwapFee int64 `protobuf:"varint,2,opt,name=max_swap_fee,json=maxSwapFee,proto3" json:"max_swap_fee,omitempty"`
	//*
	//Maximum in on-chain fees that we are willing to spent. If we want to
	//publish the on-chain htlc and the fee estimate turns out higher than this
	//value, we cancel the swap.
	//
	//max_miner_fee is typically taken from the response of the GetQuote call.
	MaxMinerFee int64 `protobuf:"varint,3,opt,name=max_miner_fee,json=maxMinerFee,proto3" json:"max_miner_fee,omitempty"`
	//*
	//The channel to loop in. If zero, the channel to loop in is selected based
	//on the lowest routing fee for the swap payment from the server.
	//
	//Note: NOT YET IMPLEMENTED
	LoopInChannel uint64 `protobuf:"varint,4,opt,name=loop_in_channel,json=loopInChannel,proto3" json:"loop_in_channel,omitempty"`
	//*
	//If external_htlc is true, we expect the htlc to be published by an external
	//actor.
	ExternalHtlc         bool     `protobuf:"varint,5,opt,name=external_htlc,json=externalHtlc,proto3" json:"external_htlc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LoopInRequest) Reset()         { *m = LoopInRequest{} }
func (m *LoopInRequest) String() string { return proto.CompactTextString(m) }
func (*LoopInRequest) ProtoMessage()    {}
func (*LoopInRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{1}
}

func (m *LoopInRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LoopInRequest.Unmarshal(m, b)
}
func (m *LoopInRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LoopInRequest.Marshal(b, m, deterministic)
}
func (m *LoopInRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoopInRequest.Merge(m, src)
}
func (m *LoopInRequest) XXX_Size() int {
	return xxx_messageInfo_LoopInRequest.Size(m)
}
func (m *LoopInRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_LoopInRequest.DiscardUnknown(m)
}

var xxx_messageInfo_LoopInRequest proto.InternalMessageInfo

func (m *LoopInRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *LoopInRequest) GetMaxSwapFee() int64 {
	if m != nil {
		return m.MaxSwapFee
	}
	return 0
}

func (m *LoopInRequest) GetMaxMinerFee() int64 {
	if m != nil {
		return m.MaxMinerFee
	}
	return 0
}

func (m *LoopInRequest) GetLoopInChannel() uint64 {
	if m != nil {
		return m.LoopInChannel
	}
	return 0
}

func (m *LoopInRequest) GetExternalHtlc() bool {
	if m != nil {
		return m.ExternalHtlc
	}
	return false
}

type SwapResponse struct {
	//*
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	//*
	//The address of the on-chain htlc.
	HtlcAddress          string   `protobuf:"bytes,2,opt,name=htlc_address,json=htlcAddress,proto3" json:"htlc_address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapResponse) Reset()         { *m = SwapResponse{} }
func (m *SwapResponse) String() string { return proto.CompactTextString(m) }
func (*SwapResponse) ProtoMessage()    {}
func (*SwapResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{2}
}

func (m *SwapResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapResponse.Unmarshal(m, b)
}
func (m *SwapResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapResponse.Marshal(b, m, deterministic)
}
func (m *SwapResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapResponse.Merge(m, src)
}
func (m *SwapResponse) XXX_Size() int {
	return xxx_messageInfo_SwapResponse.Size(m)
}
func (m *SwapResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SwapResponse proto.InternalMessageInfo

func (m *SwapResponse) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SwapResponse) GetHtlcAddress() string {
	if m != nil {
		return m.HtlcAddress
	}
	return ""
}

type MonitorRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MonitorRequest) Reset()         { *m = MonitorRequest{} }
func (m *MonitorRequest) String() string { return proto.CompactTextString(m) }
func (*MonitorRequest) ProtoMessage()    {}
func (*MonitorRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{3}
}

func (m *MonitorRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MonitorRequest.Unmarshal(m, b)
}
func (m *MonitorRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MonitorRequest.Marshal(b, m, deterministic)
}
func (m *MonitorRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MonitorRequest.Merge(m, src)
}
func (m *MonitorRequest) XXX_Size() int {
	return xxx_messageInfo_MonitorRequest.Size(m)
}
func (m *MonitorRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MonitorRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MonitorRequest proto.InternalMessageInfo

type SwapStatus struct {
	//*
	//Requested swap amount in sat. This does not include the swap and miner
	//fee.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//*
	//Swap identifier to track status in the update stream that is returned from
	//the Start() call. Currently this is the hash that locks the htlcs.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	//*
	//Swap type
	Type SwapType `protobuf:"varint,3,opt,name=type,proto3,enum=looprpc.SwapType" json:"type,omitempty"`
	//*
	//State the swap is currently in, see State enum.
	State SwapState `protobuf:"varint,4,opt,name=state,proto3,enum=looprpc.SwapState" json:"state,omitempty"`
	//*
	//Initiation time of the swap.
	InitiationTime int64 `protobuf:"varint,5,opt,name=initiation_time,json=initiationTime,proto3" json:"initiation_time,omitempty"`
	//*
	//Initiation time of the swap.
	LastUpdateTime int64 `protobuf:"varint,6,opt,name=last_update_time,json=lastUpdateTime,proto3" json:"last_update_time,omitempty"`
	//*
	//Htlc address.
	HtlcAddress string `protobuf:"bytes,7,opt,name=htlc_address,json=htlcAddress,proto3" json:"htlc_address,omitempty"`
	/// Swap server cost
	CostServer int64 `protobuf:"varint,8,opt,name=cost_server,json=costServer,proto3" json:"cost_server,omitempty"`
	// On-chain transaction cost
	CostOnchain int64 `protobuf:"varint,9,opt,name=cost_onchain,json=costOnchain,proto3" json:"cost_onchain,omitempty"`
	// Off-chain routing fees
	CostOffchain         int64    `protobuf:"varint,10,opt,name=cost_offchain,json=costOffchain,proto3" json:"cost_offchain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SwapStatus) Reset()         { *m = SwapStatus{} }
func (m *SwapStatus) String() string { return proto.CompactTextString(m) }
func (*SwapStatus) ProtoMessage()    {}
func (*SwapStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{4}
}

func (m *SwapStatus) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SwapStatus.Unmarshal(m, b)
}
func (m *SwapStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SwapStatus.Marshal(b, m, deterministic)
}
func (m *SwapStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SwapStatus.Merge(m, src)
}
func (m *SwapStatus) XXX_Size() int {
	return xxx_messageInfo_SwapStatus.Size(m)
}
func (m *SwapStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SwapStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SwapStatus proto.InternalMessageInfo

func (m *SwapStatus) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *SwapStatus) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SwapStatus) GetType() SwapType {
	if m != nil {
		return m.Type
	}
	return SwapType_LOOP_OUT
}

func (m *SwapStatus) GetState() SwapState {
	if m != nil {
		return m.State
	}
	return SwapState_INITIATED
}

func (m *SwapStatus) GetInitiationTime() int64 {
	if m != nil {
		return m.InitiationTime
	}
	return 0
}

func (m *SwapStatus) GetLastUpdateTime() int64 {
	if m != nil {
		return m.LastUpdateTime
	}
	return 0
}

func (m *SwapStatus) GetHtlcAddress() string {
	if m != nil {
		return m.HtlcAddress
	}
	return ""
}

func (m *SwapStatus) GetCostServer() int64 {
	if m != nil {
		return m.CostServer
	}
	return 0
}

func (m *SwapStatus) GetCostOnchain() int64 {
	if m != nil {
		return m.CostOnchain
	}
	return 0
}

func (m *SwapStatus) GetCostOffchain() int64 {
	if m != nil {
		return m.CostOffchain
	}
	return 0
}

type TermsRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TermsRequest) Reset()         { *m = TermsRequest{} }
func (m *TermsRequest) String() string { return proto.CompactTextString(m) }
func (*TermsRequest) ProtoMessage()    {}
func (*TermsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{5}
}

func (m *TermsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TermsRequest.Unmarshal(m, b)
}
func (m *TermsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TermsRequest.Marshal(b, m, deterministic)
}
func (m *TermsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TermsRequest.Merge(m, src)
}
func (m *TermsRequest) XXX_Size() int {
	return xxx_messageInfo_TermsRequest.Size(m)
}
func (m *TermsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TermsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TermsRequest proto.InternalMessageInfo

type TermsResponse struct {
	//*
	//Minimum swap amount (sat)
	MinSwapAmount int64 `protobuf:"varint,5,opt,name=min_swap_amount,json=minSwapAmount,proto3" json:"min_swap_amount,omitempty"`
	//*
	//Maximum swap amount (sat)
	MaxSwapAmount        int64    `protobuf:"varint,6,opt,name=max_swap_amount,json=maxSwapAmount,proto3" json:"max_swap_amount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TermsResponse) Reset()         { *m = TermsResponse{} }
func (m *TermsResponse) String() string { return proto.CompactTextString(m) }
func (*TermsResponse) ProtoMessage()    {}
func (*TermsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{6}
}

func (m *TermsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TermsResponse.Unmarshal(m, b)
}
func (m *TermsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TermsResponse.Marshal(b, m, deterministic)
}
func (m *TermsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TermsResponse.Merge(m, src)
}
func (m *TermsResponse) XXX_Size() int {
	return xxx_messageInfo_TermsResponse.Size(m)
}
func (m *TermsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TermsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TermsResponse proto.InternalMessageInfo

func (m *TermsResponse) GetMinSwapAmount() int64 {
	if m != nil {
		return m.MinSwapAmount
	}
	return 0
}

func (m *TermsResponse) GetMaxSwapAmount() int64 {
	if m != nil {
		return m.MaxSwapAmount
	}
	return 0
}

type QuoteRequest struct {
	//*
	//The amount to swap in satoshis.
	Amt int64 `protobuf:"varint,1,opt,name=amt,proto3" json:"amt,omitempty"`
	//*
	//The confirmation target that should be used either for the sweep of the
	//on-chain HTLC broadcast by the swap server in the case of a Loop Out, or for
	//the confirmation of the on-chain HTLC broadcast by the swap client in the
	//case of a Loop In.
	ConfTarget int32 `protobuf:"varint,2,opt,name=conf_target,json=confTarget,proto3" json:"conf_target,omitempty"`
	//*
	//If external_htlc is true, we expect the htlc to be published by an external
	//actor.
	ExternalHtlc         bool     `protobuf:"varint,3,opt,name=external_htlc,json=externalHtlc,proto3" json:"external_htlc,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QuoteRequest) Reset()         { *m = QuoteRequest{} }
func (m *QuoteRequest) String() string { return proto.CompactTextString(m) }
func (*QuoteRequest) ProtoMessage()    {}
func (*QuoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{7}
}

func (m *QuoteRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QuoteRequest.Unmarshal(m, b)
}
func (m *QuoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QuoteRequest.Marshal(b, m, deterministic)
}
func (m *QuoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuoteRequest.Merge(m, src)
}
func (m *QuoteRequest) XXX_Size() int {
	return xxx_messageInfo_QuoteRequest.Size(m)
}
func (m *QuoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuoteRequest proto.InternalMessageInfo

func (m *QuoteRequest) GetAmt() int64 {
	if m != nil {
		return m.Amt
	}
	return 0
}

func (m *QuoteRequest) GetConfTarget() int32 {
	if m != nil {
		return m.ConfTarget
	}
	return 0
}

func (m *QuoteRequest) GetExternalHtlc() bool {
	if m != nil {
		return m.ExternalHtlc
	}
	return false
}

type QuoteResponse struct {
	//*
	//The fee that the swap server is charging for the swap.
	SwapFee int64 `protobuf:"varint,1,opt,name=swap_fee,json=swapFee,proto3" json:"swap_fee,omitempty"`
	//*
	//The part of the swap fee that is requested as a prepayment.
	PrepayAmt int64 `protobuf:"varint,2,opt,name=prepay_amt,json=prepayAmt,proto3" json:"prepay_amt,omitempty"`
	//*
	//An estimate of the on-chain fee that needs to be paid to sweep the HTLC.
	MinerFee int64 `protobuf:"varint,3,opt,name=miner_fee,json=minerFee,proto3" json:"miner_fee,omitempty"`
	//*
	//The node pubkey where the swap payment needs to be paid
	//to. This can be used to test connectivity before initiating the swap.
	SwapPaymentDest []byte `protobuf:"bytes,4,opt,name=swap_payment_dest,json=swapPaymentDest,proto3" json:"swap_payment_dest,omitempty"`
	//*
	//On-chain cltv expiry delta
	CltvDelta            int32    `protobuf:"varint,5,opt,name=cltv_delta,json=cltvDelta,proto3" json:"cltv_delta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QuoteResponse) Reset()         { *m = QuoteResponse{} }
func (m *QuoteResponse) String() string { return proto.CompactTextString(m) }
func (*QuoteResponse) ProtoMessage()    {}
func (*QuoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_014de31d7ac8c57c, []int{8}
}

func (m *QuoteResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QuoteResponse.Unmarshal(m, b)
}
func (m *QuoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QuoteResponse.Marshal(b, m, deterministic)
}
func (m *QuoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuoteResponse.Merge(m, src)
}
func (m *QuoteResponse) XXX_Size() int {
	return xxx_messageInfo_QuoteResponse.Size(m)
}
func (m *QuoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuoteResponse proto.InternalMessageInfo

func (m *QuoteResponse) GetSwapFee() int64 {
	if m != nil {
		return m.SwapFee
	}
	return 0
}

func (m *QuoteResponse) GetPrepayAmt() int64 {
	if m != nil {
		return m.PrepayAmt
	}
	return 0
}

func (m *QuoteResponse) GetMinerFee() int64 {
	if m != nil {
		return m.MinerFee
	}
	return 0
}

func (m *QuoteResponse) GetSwapPaymentDest() []byte {
	if m != nil {
		return m.SwapPaymentDest
	}
	return nil
}

func (m *QuoteResponse) GetCltvDelta() int32 {
	if m != nil {
		return m.CltvDelta
	}
	return 0
}

func init() {
	proto.RegisterEnum("looprpc.SwapType", SwapType_name, SwapType_value)
	proto.RegisterEnum("looprpc.SwapState", SwapState_name, SwapState_value)
	proto.RegisterType((*LoopOutRequest)(nil), "looprpc.LoopOutRequest")
	proto.RegisterType((*LoopInRequest)(nil), "looprpc.LoopInRequest")
	proto.RegisterType((*SwapResponse)(nil), "looprpc.SwapResponse")
	proto.RegisterType((*MonitorRequest)(nil), "looprpc.MonitorRequest")
	proto.RegisterType((*SwapStatus)(nil), "looprpc.SwapStatus")
	proto.RegisterType((*TermsRequest)(nil), "looprpc.TermsRequest")
	proto.RegisterType((*TermsResponse)(nil), "looprpc.TermsResponse")
	proto.RegisterType((*QuoteRequest)(nil), "looprpc.QuoteRequest")
	proto.RegisterType((*QuoteResponse)(nil), "looprpc.QuoteResponse")
}

func init() { proto.RegisterFile("client.proto", fileDescriptor_014de31d7ac8c57c) }

var fileDescriptor_014de31d7ac8c57c = []byte{
	// 1061 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x56, 0x4f, 0x73, 0xda, 0x46,
	0x1c, 0x8d, 0x40, 0x18, 0xf1, 0xb3, 0x90, 0xc5, 0x3a, 0x71, 0x08, 0x6d, 0x26, 0x94, 0x36, 0x29,
	0xe3, 0x83, 0x69, 0x9d, 0x53, 0x7b, 0xa3, 0x98, 0xc4, 0x78, 0x6c, 0xe3, 0x0a, 0x9c, 0x99, 0xf6,
	0xa2, 0x6e, 0x61, 0xb1, 0x35, 0x83, 0x76, 0x15, 0x69, 0xf1, 0x9f, 0xe9, 0xe4, 0xd2, 0xaf, 0xd0,
	0x4f, 0xd2, 0x99, 0x7e, 0x93, 0xde, 0x7b, 0xea, 0xf4, 0x73, 0x74, 0xf6, 0xb7, 0x42, 0x16, 0x26,
	0xbe, 0xe4, 0x66, 0x9e, 0xde, 0xbe, 0xdf, 0x1f, 0xbd, 0xb7, 0x32, 0xd8, 0x93, 0x79, 0xc0, 0xb8,
	0xdc, 0x8b, 0x62, 0x21, 0x05, 0x29, 0xcf, 0x85, 0x88, 0xe2, 0x68, 0xd2, 0xf8, 0xfc, 0x42, 0x88,
	0x8b, 0x39, 0xeb, 0xd0, 0x28, 0xe8, 0x50, 0xce, 0x85, 0xa4, 0x32, 0x10, 0x3c, 0xd1, 0xb4, 0xd6,
	0x3f, 0x05, 0x70, 0x8e, 0x85, 0x88, 0x86, 0x0b, 0xe9, 0xb1, 0xf7, 0x0b, 0x96, 0x48, 0xe2, 0x42,
	0x91, 0x86, 0xb2, 0x6e, 0x34, 0x8d, 0x76, 0xd1, 0x53, 0x7f, 0x12, 0x02, 0xe6, 0x94, 0x25, 0xb2,
	0x5e, 0x68, 0x1a, 0xed, 0x8a, 0x87, 0x7f, 0x93, 0x0e, 0x3c, 0x0e, 0xe9, 0x8d, 0x9f, 0x5c, 0xd3,
	0xc8, 0x8f, 0xc5, 0x42, 0x06, 0xfc, 0xc2, 0x9f, 0x31, 0x56, 0x2f, 0xe2, 0xb1, 0x5a, 0x48, 0x6f,
	0x46, 0xd7, 0x34, 0xf2, 0xf4, 0x93, 0x37, 0x8c, 0x91, 0xd7, 0xb0, 0xa3, 0x0e, 0x44, 0x31, 0x8b,
	0xe8, 0xed, 0xca, 0x11, 0x13, 0x8f, 0x6c, 0x87, 0xf4, 0xe6, 0x0c, 0x1f, 0xe6, 0x0e, 0x35, 0xc1,
	0xce, 0xaa, 0x28, 0x6a, 0x09, 0xa9, 0x90, 0xaa, 0x2b, 0xc6, 0x57, 0xe0, 0xe4, 0x64, 0x55, 0xe3,
	0x1b, 0xc8, 0xb1, 0x33, 0xb9, 0x6e, 0x28, 0x49, 0x0b, 0xaa, 0x8a, 0x15, 0x06, 0x9c, 0xc5, 0x28,
	0x54, 0x46, 0xd2, 0x66, 0x48, 0x6f, 0x4e, 0x14, 0xa6, 0x94, 0xda, 0xe0, 0xaa, 0x9d, 0xf9, 0x62,
	0x21, 0xfd, 0xc9, 0x25, 0xe5, 0x9c, 0xcd, 0xeb, 0x56, 0xd3, 0x68, 0x9b, 0x9e, 0x33, 0xd7, 0x1b,
	0xea, 0x69, 0x94, 0xec, 0x42, 0x2d, 0xb9, 0x66, 0x2c, 0xf2, 0x27, 0x82, 0xcf, 0x7c, 0x49, 0xe3,
	0x0b, 0x26, 0xeb, 0x95, 0xa6, 0xd1, 0x2e, 0x79, 0x5b, 0xf8, 0xa0, 0x27, 0xf8, 0x6c, 0x8c, 0x70,
	0xeb, 0x2f, 0x03, 0xaa, 0x6a, 0xc1, 0x03, 0xfe, 0xf0, 0x7e, 0xef, 0x4f, 0x59, 0x58, 0x9b, 0x72,
	0xad, 0xff, 0xe2, 0x7a, 0xff, 0xaf, 0x60, 0x0b, 0xfb, 0x0f, 0x78, 0xd6, 0xbe, 0x89, 0xed, 0x57,
	0xe7, 0x58, 0x7f, 0xd9, 0xfd, 0x97, 0x50, 0x65, 0x37, 0x92, 0xc5, 0x9c, 0xce, 0xfd, 0x4b, 0x39,
	0x9f, 0xe0, 0x52, 0x2d, 0xcf, 0x5e, 0x82, 0x87, 0x72, 0x3e, 0x69, 0x75, 0xc1, 0xc6, 0xf7, 0xc7,
	0x92, 0x48, 0xf0, 0x84, 0x11, 0x07, 0x0a, 0xc1, 0x14, 0x7b, 0xae, 0x78, 0x85, 0x60, 0x4a, 0xbe,
	0x00, 0x5b, 0x9d, 0xf5, 0xe9, 0x74, 0x1a, 0xb3, 0x24, 0x49, 0xad, 0xb1, 0xa9, 0xb0, 0xae, 0x86,
	0x5a, 0x2e, 0x38, 0x27, 0x82, 0x07, 0x52, 0xc4, 0xe9, 0xe4, 0xca, 0x6c, 0xa0, 0x54, 0x47, 0x92,
	0xca, 0x45, 0xf2, 0x91, 0x45, 0xe8, 0x2a, 0x85, 0xac, 0xca, 0x4b, 0x30, 0xe5, 0x6d, 0xa4, 0xa7,
	0x75, 0xf6, 0x6b, 0x7b, 0xa9, 0xa7, 0xf7, 0x94, 0xc8, 0xf8, 0x36, 0x62, 0x1e, 0x3e, 0x26, 0x6d,
	0x28, 0x25, 0x92, 0x4a, 0xed, 0x24, 0x67, 0x9f, 0xac, 0xf0, 0x54, 0x31, 0xe6, 0x69, 0x02, 0xf9,
	0x1a, 0xb6, 0x02, 0x1e, 0xc8, 0x00, 0x33, 0xe0, 0xcb, 0x20, 0x5c, 0x5a, 0xca, 0xb9, 0x83, 0xc7,
	0x41, 0xa8, 0xcd, 0x40, 0x13, 0xe9, 0x2f, 0xa2, 0x29, 0x95, 0x4c, 0x33, 0xb5, 0xb1, 0x1c, 0x85,
	0x9f, 0x23, 0x8c, 0xcc, 0xfb, 0x9b, 0x28, 0xaf, 0x6d, 0x82, 0xbc, 0x80, 0xcd, 0x89, 0x48, 0xa4,
	0x9f, 0xb0, 0xf8, 0x8a, 0xc5, 0x68, 0xaa, 0xa2, 0x07, 0x0a, 0x1a, 0x21, 0xa2, 0x34, 0x90, 0x20,
	0xf8, 0xe4, 0x92, 0x06, 0x1c, 0xbd, 0x54, 0xf4, 0xf0, 0xd0, 0x50, 0x43, 0xea, 0xad, 0x69, 0xca,
	0x6c, 0xa6, 0x39, 0xa0, 0x6d, 0x8e, 0x9c, 0x14, 0x6b, 0x39, 0x60, 0x8f, 0x59, 0x1c, 0x26, 0xcb,
	0x85, 0x7f, 0x80, 0x6a, 0xfa, 0x3b, 0x7d, 0x8d, 0xaf, 0x60, 0x2b, 0x0c, 0xb8, 0x76, 0x1a, 0x0d,
	0xc5, 0x82, 0xcb, 0x74, 0xfe, 0x6a, 0x18, 0x70, 0xb5, 0xad, 0x2e, 0x82, 0xc8, 0x5b, 0x3a, 0x32,
	0xe5, 0x6d, 0xa4, 0x3c, 0x6d, 0x4a, 0xcd, 0x3b, 0x32, 0x2d, 0xc3, 0x2d, 0x1c, 0x99, 0x56, 0xc1,
	0x2d, 0x1e, 0x99, 0x56, 0xd1, 0x35, 0x8f, 0x4c, 0xcb, 0x74, 0x4b, 0x47, 0xa6, 0x55, 0x76, 0xad,
	0xd6, 0x0c, 0xec, 0x1f, 0x17, 0x42, 0xb2, 0x87, 0x9d, 0x8f, 0x9b, 0xb9, 0xcb, 0x50, 0x01, 0x33,
	0x04, 0x93, 0x2c, 0x3e, 0xeb, 0x66, 0x2d, 0x7e, 0xc4, 0xac, 0x7f, 0x1a, 0x50, 0x4d, 0x0b, 0xa5,
	0x73, 0x3e, 0x03, 0x2b, 0x4b, 0x93, 0x2e, 0x57, 0x4e, 0xd2, 0x28, 0x3d, 0x07, 0xc8, 0x5d, 0x16,
	0x3a, 0x6a, 0x95, 0x28, 0xbb, 0x29, 0x3e, 0x83, 0xca, 0xfd, 0x94, 0x59, 0xe1, 0x32, 0x62, 0x18,
	0x7c, 0x1a, 0xf9, 0x11, 0xbd, 0x0d, 0x19, 0x97, 0x3e, 0xde, 0x8a, 0xca, 0x74, 0xb6, 0x0a, 0x3e,
	0x8d, 0xce, 0x34, 0x7e, 0xa0, 0x86, 0x7d, 0x0e, 0x30, 0x99, 0xcb, 0x2b, 0x7f, 0xca, 0xe6, 0x92,
	0xe2, 0x96, 0x4b, 0x5e, 0x45, 0x21, 0x07, 0x0a, 0xd8, 0x7d, 0x09, 0xd6, 0xd2, 0xc5, 0xc4, 0x06,
	0xeb, 0x78, 0x38, 0x3c, 0xf3, 0x87, 0xe7, 0x63, 0xf7, 0x11, 0xd9, 0x84, 0x32, 0xfe, 0x1a, 0x9c,
	0xba, 0xc6, 0x6e, 0x02, 0x95, 0xcc, 0xc4, 0xa4, 0x0a, 0x95, 0xc1, 0xe9, 0x60, 0x3c, 0xe8, 0x8e,
	0xfb, 0x07, 0xee, 0x23, 0xf2, 0x04, 0x6a, 0x67, 0x5e, 0x7f, 0x70, 0xd2, 0x7d, 0xdb, 0xf7, 0xbd,
	0xfe, 0xbb, 0x7e, 0xf7, 0xb8, 0x7f, 0xe0, 0x1a, 0x84, 0x80, 0x73, 0x38, 0x3e, 0xee, 0xf9, 0x67,
	0xe7, 0x3f, 0x1c, 0x0f, 0x46, 0x87, 0xfd, 0x03, 0xb7, 0xa0, 0x34, 0x47, 0xe7, 0xbd, 0x5e, 0x7f,
	0x34, 0x72, 0x8b, 0x04, 0x60, 0xe3, 0x4d, 0x77, 0xa0, 0xc8, 0x26, 0xd9, 0x86, 0xad, 0xc1, 0xe9,
	0xbb, 0xe1, 0xa0, 0xd7, 0xf7, 0x47, 0xfd, 0xf1, 0x58, 0x81, 0xa5, 0xfd, 0xff, 0x4c, 0x9d, 0xd3,
	0x1e, 0x7e, 0x50, 0x88, 0x07, 0xe5, 0xf4, 0x13, 0x41, 0x9e, 0x66, 0xd1, 0x5a, 0xfd, 0x68, 0x34,
	0x9e, 0xac, 0x64, 0x6e, 0xf9, 0x1e, 0x5a, 0x4f, 0x7f, 0xff, 0xfb, 0xdf, 0x3f, 0x0a, 0xb5, 0x96,
	0xdd, 0xb9, 0xfa, 0xb6, 0xa3, 0x18, 0x1d, 0xb1, 0x90, 0xdf, 0x1b, 0xbb, 0x64, 0x08, 0x1b, 0xfa,
	0x56, 0x24, 0x3b, 0x2b, 0x92, 0xd9, 0x35, 0xf9, 0x90, 0xe2, 0x0e, 0x2a, 0xba, 0xad, 0xcd, 0x4c,
	0x31, 0xe0, 0x4a, 0xf0, 0x3b, 0x28, 0xa7, 0xb7, 0x4d, 0xae, 0xc9, 0xd5, 0xfb, 0xa7, 0xb1, 0xbd,
	0x76, 0x31, 0x2c, 0x92, 0x6f, 0x0c, 0xf2, 0x13, 0xd8, 0xe9, 0x34, 0x18, 0x16, 0x72, 0x57, 0x39,
	0x1f, 0xa6, 0xc6, 0xce, 0x7d, 0x38, 0xed, 0xa8, 0x81, 0x1d, 0x3d, 0x26, 0x24, 0x3f, 0x63, 0x47,
	0xa2, 0x94, 0x9f, 0x49, 0xa3, 0x3f, 0x73, 0xd2, 0xf9, 0x60, 0xe4, 0xa4, 0x57, 0x6c, 0xdc, 0x6a,
	0xa2, 0x74, 0x83, 0xd4, 0x57, 0xa4, 0xdf, 0x2b, 0x4e, 0xe7, 0x37, 0x1a, 0xca, 0x0f, 0xe4, 0x67,
	0x70, 0xde, 0x32, 0xa9, 0x37, 0xf7, 0x49, 0xdd, 0x3f, 0xc3, 0x12, 0xdb, 0xa4, 0x96, 0xdb, 0x67,
	0xda, 0xfc, 0x2f, 0x39, 0xed, 0x4f, 0x6a, 0xff, 0x05, 0x6a, 0x3f, 0x23, 0x4f, 0xf3, 0xda, 0xb9,
	0xee, 0x7f, 0xdd, 0xc0, 0x7f, 0x42, 0x5e, 0xff, 0x1f, 0x00, 0x00, 0xff, 0xff, 0x26, 0x06, 0x26,
	0x30, 0xbb, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SwapClientClient is the client API for SwapClient service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SwapClientClient interface {
	//* loop: `out`
	//LoopOut initiates an loop out swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream that is
	//returned from Monitor().
	LoopOut(ctx context.Context, in *LoopOutRequest, opts ...grpc.CallOption) (*SwapResponse, error)
	//*
	//LoopIn initiates a loop in swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream
	//that is returned from Monitor().
	LoopIn(ctx context.Context, in *LoopInRequest, opts ...grpc.CallOption) (*SwapResponse, error)
	//* loop: `monitor`
	//Monitor will return a stream of swap updates for currently active swaps.
	//TODO: add MonitorSync version for REST clients.
	Monitor(ctx context.Context, in *MonitorRequest, opts ...grpc.CallOption) (SwapClient_MonitorClient, error)
	//* loop: `terms`
	//LoopOutTerms returns the terms that the server enforces for a loop out swap.
	LoopOutTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*TermsResponse, error)
	//* loop: `quote`
	//LoopOutQuote returns a quote for a loop out swap with the provided
	//parameters.
	LoopOutQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*QuoteResponse, error)
	//*
	//GetTerms returns the terms that the server enforces for swaps.
	GetLoopInTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*TermsResponse, error)
	//*
	//GetQuote returns a quote for a swap with the provided parameters.
	GetLoopInQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*QuoteResponse, error)
}

type swapClientClient struct {
	cc *grpc.ClientConn
}

func NewSwapClientClient(cc *grpc.ClientConn) SwapClientClient {
	return &swapClientClient{cc}
}

func (c *swapClientClient) LoopOut(ctx context.Context, in *LoopOutRequest, opts ...grpc.CallOption) (*SwapResponse, error) {
	out := new(SwapResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOut", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopIn(ctx context.Context, in *LoopInRequest, opts ...grpc.CallOption) (*SwapResponse, error) {
	out := new(SwapResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopIn", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) Monitor(ctx context.Context, in *MonitorRequest, opts ...grpc.CallOption) (SwapClient_MonitorClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SwapClient_serviceDesc.Streams[0], "/looprpc.SwapClient/Monitor", opts...)
	if err != nil {
		return nil, err
	}
	x := &swapClientMonitorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SwapClient_MonitorClient interface {
	Recv() (*SwapStatus, error)
	grpc.ClientStream
}

type swapClientMonitorClient struct {
	grpc.ClientStream
}

func (x *swapClientMonitorClient) Recv() (*SwapStatus, error) {
	m := new(SwapStatus)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *swapClientClient) LoopOutTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*TermsResponse, error) {
	out := new(TermsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOutTerms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) LoopOutQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*QuoteResponse, error) {
	out := new(QuoteResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/LoopOutQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLoopInTerms(ctx context.Context, in *TermsRequest, opts ...grpc.CallOption) (*TermsResponse, error) {
	out := new(TermsResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLoopInTerms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *swapClientClient) GetLoopInQuote(ctx context.Context, in *QuoteRequest, opts ...grpc.CallOption) (*QuoteResponse, error) {
	out := new(QuoteResponse)
	err := c.cc.Invoke(ctx, "/looprpc.SwapClient/GetLoopInQuote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SwapClientServer is the server API for SwapClient service.
type SwapClientServer interface {
	//* loop: `out`
	//LoopOut initiates an loop out swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream that is
	//returned from Monitor().
	LoopOut(context.Context, *LoopOutRequest) (*SwapResponse, error)
	//*
	//LoopIn initiates a loop in swap with the given parameters. The call
	//returns after the swap has been set up with the swap server. From that
	//point onwards, progress can be tracked via the SwapStatus stream
	//that is returned from Monitor().
	LoopIn(context.Context, *LoopInRequest) (*SwapResponse, error)
	//* loop: `monitor`
	//Monitor will return a stream of swap updates for currently active swaps.
	//TODO: add MonitorSync version for REST clients.
	Monitor(*MonitorRequest, SwapClient_MonitorServer) error
	//* loop: `terms`
	//LoopOutTerms returns the terms that the server enforces for a loop out swap.
	LoopOutTerms(context.Context, *TermsRequest) (*TermsResponse, error)
	//* loop: `quote`
	//LoopOutQuote returns a quote for a loop out swap with the provided
	//parameters.
	LoopOutQuote(context.Context, *QuoteRequest) (*QuoteResponse, error)
	//*
	//GetTerms returns the terms that the server enforces for swaps.
	GetLoopInTerms(context.Context, *TermsRequest) (*TermsResponse, error)
	//*
	//GetQuote returns a quote for a swap with the provided parameters.
	GetLoopInQuote(context.Context, *QuoteRequest) (*QuoteResponse, error)
}

func RegisterSwapClientServer(s *grpc.Server, srv SwapClientServer) {
	s.RegisterService(&_SwapClient_serviceDesc, srv)
}

func _SwapClient_LoopOut_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoopOutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOut(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOut",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOut(ctx, req.(*LoopOutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopIn_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoopInRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopIn(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopIn",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopIn(ctx, req.(*LoopInRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_Monitor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MonitorRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SwapClientServer).Monitor(m, &swapClientMonitorServer{stream})
}

type SwapClient_MonitorServer interface {
	Send(*SwapStatus) error
	grpc.ServerStream
}

type swapClientMonitorServer struct {
	grpc.ServerStream
}

func (x *swapClientMonitorServer) Send(m *SwapStatus) error {
	return x.ServerStream.SendMsg(m)
}

func _SwapClient_LoopOutTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOutTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOutTerms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOutTerms(ctx, req.(*TermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_LoopOutQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).LoopOutQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/LoopOutQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).LoopOutQuote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLoopInTerms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TermsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLoopInTerms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLoopInTerms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLoopInTerms(ctx, req.(*TermsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SwapClient_GetLoopInQuote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SwapClientServer).GetLoopInQuote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/looprpc.SwapClient/GetLoopInQuote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SwapClientServer).GetLoopInQuote(ctx, req.(*QuoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SwapClient_serviceDesc = grpc.ServiceDesc{
	ServiceName: "looprpc.SwapClient",
	HandlerType: (*SwapClientServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoopOut",
			Handler:    _SwapClient_LoopOut_Handler,
		},
		{
			MethodName: "LoopIn",
			Handler:    _SwapClient_LoopIn_Handler,
		},
		{
			MethodName: "LoopOutTerms",
			Handler:    _SwapClient_LoopOutTerms_Handler,
		},
		{
			MethodName: "LoopOutQuote",
			Handler:    _SwapClient_LoopOutQuote_Handler,
		},
		{
			MethodName: "GetLoopInTerms",
			Handler:    _SwapClient_GetLoopInTerms_Handler,
		},
		{
			MethodName: "GetLoopInQuote",
			Handler:    _SwapClient_GetLoopInQuote_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Monitor",
			Handler:       _SwapClient_Monitor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "client.proto",
}
